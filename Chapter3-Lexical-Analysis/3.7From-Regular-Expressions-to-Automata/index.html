<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="DengKing">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>3.7 From Regular Expressions to Automata - compiler principle</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="../../css/extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "3.7 From Regular Expressions to Automata";
    var mkdocs_page_input_path = "Chapter3-Lexical-Analysis/3.7From-Regular-Expressions-to-Automata.md";
    var mkdocs_page_url = "/compiler-principle/Chapter3-Lexical-Analysis/3.7From-Regular-Expressions-to-Automata/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/django.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> compiler principle</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <span class="caption-text">Chapter1-Introduction</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Chapter1-Introduction/introduction/">introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Chapter1-Introduction/1.2The-Structure-of-a-Compiler/">1.2 The Structure of a Compiler</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Chapter2-A-Simple-Syntax-Directed-Translator</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Chapter2-A-Simple-Syntax-Directed-Translator/A-Simple-Syntax-Directed-Translator/">A-Simple-Syntax-Directed-Translator</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Chapter2-A-Simple-Syntax-Directed-Translator/2.1Introduction/">2.1 Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Chapter2-A-Simple-Syntax-Directed-Translator/2.2Syntax-Definition/">2.2 Syntax Definition</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Chapter2-A-Simple-Syntax-Directed-Translator/2.3Syntax-Directed-Translation/">2.3 Syntax-Directed Translation</a>
                </li>
                <li class="">
                    
    <a class="" href="../../Chapter2-A-Simple-Syntax-Directed-Translator/2.4Parsing/">2.4 Parsing</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Chapter3-Lexical-Analysis</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Lexical-Analysis/">Lexical-Analysis</a>
                </li>
                <li class="">
                    
    <a class="" href="../3.1The-Role-of-the-Lexical-Analyzer/">3.1 The Role of the Lexical Analyzer</a>
                </li>
                <li class="">
                    
    <a class="" href="../3.4Recognition-of-Tokens/">3.4 Recognition of Tokens</a>
                </li>
                <li class="">
                    
    <a class="" href="../3.6Finite-Automata/">3.6 Finite Automata</a>
                </li>
                <li class="">
                    
    <a class="" href="../3.7-From-Regular-Expressions-to-Automata.md">3.7 From Regular Expressions to Automata</a>
                </li>
                <li class="">
                    
    <span class="caption-text">wikipedia String</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../wikipedia-String/wikipedia-String(computer-science)/">wikipedia-String(computer-science)</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../wikipedia-String/string-searching/wikipedia-Aho–Corasick-algorithm.md">string searching</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../wikipedia-String/Regular-expression/wikipedia-Powerset-construction/">Regular expression</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">compiler principle</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>3.7 From Regular Expressions to Automata</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="37-from-regular-expressions-to-automata">3.7 From Regular Expressions to Automata<a class="headerlink" href="#37-from-regular-expressions-to-automata" title="Permanent link"></a></h1>
<blockquote>
<p>NOTE: What this chapter describe is mainly three algorithms</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson's construction algorithm</a></td>
<td>transforming a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a> into an equivalent <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">nondeterministic finite automaton</a> (NFA)</td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Subset_construction_algorithm">subset construction algorithm</a></td>
<td><a href="https://en.wikipedia.org/wiki/Automata_construction">converting</a> a <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">nondeterministic finite automaton</a> (NFA) into a <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automaton</a> (DFA) which recognizes the same <a href="https://en.wikipedia.org/wiki/Formal_language">formal language</a></td>
</tr>
<tr>
<td><a href="https://en.wikipedia.org/wiki/DFA_minimization">DFA minimization</a></td>
<td>transforming a given <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automaton</a> (DFA) into an equivalent DFA that has a minimum number of states.</td>
</tr>
</tbody>
</table>
<p>Using the two algorithms above, a regular expression can be converted to the corresponding NFA or DFA. </p>
</blockquote>
<p>The regular expression is the notation of choice for describing lexical analyzers and other pattern-processing software, as was reflected in Section 3.5. However, implementation of that software requires the simulation of a DFA, as in Algorithm 3.18, or perhaps simulation of an NFA. Because an NFA often has a choice of move on an input symbol (as Fig. 3.24 does on input a from state 0) or on $\epsilon$ (as Fig. 3.26 does from state 0), or even a choice of making a transition on $\epsilon$  or on a real input symbol, its simulation is less straightforward than for a DFA. Thus often it is important to convert an NFA to a DFA that accepts the
same language.</p>
<h2 id="371-conversion-of-an-nfa-to-a-dfa">3.7.1 Conversion of an NFA to a DFA<a class="headerlink" href="#371-conversion-of-an-nfa-to-a-dfa" title="Permanent link"></a></h2>
<blockquote>
<p>NOTE: The subset construction explained in this book is too abstract to grasp, <a href="https://en.wikipedia.org/wiki/Powerset_construction">wikipedia's explanation about this algorithm</a> is more intuitionistic.</p>
</blockquote>
<p>The general idea behind the subset construction is that each state of the constructed DFA corresponds to a set of NFA states. After reading input $a_1 a_2 \dots a_n$, the DFA is in that state which corresponds to the set of states that the NFA can reach, from its start state, following paths labeled $a_1 a_2 \dots a_n$.</p>
<p>It is p ossible that the number of DFA states is exponential in the number of NFA states, which could lead to difficulties when we try to implement this DFA. However, part of the p ower of the automaton-based approach to lexical analysis is that for real languages, the NFA and DFA have approximately the same number of states, and the exponential behavior is not seen.</p>
<p><strong>Algorithm 3.20</strong> : The <em>subset construction</em> of a DFA from an NFA.</p>
<p><strong>INPUT</strong>: An <strong>NFA</strong> <code>N</code> .</p>
<p><strong>OUTPUT</strong>: A DFA <code>D</code> accepting the same language as <code>N</code> .</p>
<p><strong>METHOD</strong>: Our algorithm constructs a transition table $D_{tran}$ for <code>D</code> . Each state of <code>D</code> is a set of NFA states, and we construct $D_{tran}$ so <code>D</code> will simulate "in parallel" all possible moves <code>N</code> can make on a given input string. Our first problem is to deal with $\epsilon$-transitions of <code>N</code> properly. In Fig. 3.31 we see the definitions of several functions that describe basic computations on the states of <code>N</code> that are needed in the algorithm. Note that <code>s</code> is a single state of <code>N</code> , while <code>T</code>  is a set of states of <code>N</code> .</p>
<table>
<thead>
<tr>
<th>OPERATION</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\epsilon-closure(s)$</td>
<td>Set of NFA states reachable from NFA state <code>s</code> on $\epsilon$-transitions alone.</td>
</tr>
<tr>
<td>$\epsilon-closure(T)$</td>
<td>Set of NFA states reachable from some NFA state <code>s</code> in set <code>T</code> on $\epsilon$-transitions alone; $= \cup _{s \in T} {\epsilon-closure(s)}$</td>
</tr>
<tr>
<td><code>move(T, a)</code></td>
<td>Set of NFA states to which there is a transition on input symbol a from some state <code>s</code> in <code>T</code> .</td>
</tr>
</tbody>
</table>
<p>Figure 3.31: Operations on NFA states</p>
<p>We must explore those sets of states that <code>N</code> can be in after seeing some input string. As a basis, before reading the first input symbol, <code>N</code> can be in any of the states of $\epsilon-closure(s_0)$, where $s_0$ is its <strong>start state</strong>. For the induction, suppose that <code>N</code> can be in set of states <code>T</code> after reading input string <code>x</code>. If it next reads
input <code>a</code>, then <code>N</code> can immediately go to any of the states in $move (T , a)$. However, after reading <code>a</code>, it may also make several $\epsilon-transitions$; thus <code>N</code> could be in any state of $\epsilon-closure(move(T, a))$ after reading input <code>xa</code>. Following these ideas, the construction of the set of <code>D</code> 's states, $D_{states}$, and its transition function $D_{tran}$, is shown in Fig. 3.32.</p>
<p><img alt="" src="../Figure3.32The-subset-construction.jpg" /></p>
<p>The <strong>start state</strong> of <code>D</code> is $\epsilon-closure(s_0)$, and the accepting states of <code>D</code> are all those sets of <code>N</code> 's states that include at least one accepting state of N . To complete our description of the subset construction, we need only to show how $\epsilon-closure(T)$ is computed for any set of NFA states <code>T</code> .  This process, shown in
Fig. 3.33, is a straightforward search in a graph from a set of states. In this case, imagine that only the $\epsilon$-labeled edges are available in the graph. </p>
<p><img alt="" src="../Figure3.33Computing-closure(T).jpg" /></p>
<h2 id="374-construction-of-an-nfa-from-a-regular-expression">3.7.4 Construction of an NFA from a Regular Expression<a class="headerlink" href="#374-construction-of-an-nfa-from-a-regular-expression" title="Permanent link"></a></h2>
<p>We now give an algorithm for converting any regular expression to an NFA that defines the same language. The algorithm is <strong>syntax-directed</strong>, in the sense that it works recursively up the <strong>parse tree</strong> for the regular expression. For each sub expression the algorithm constructs an NFA with a single accepting state.</p>
<blockquote>
<p>NOTE: bottom-up</p>
<p>NOTE: How to build a parse tree for a regular expression? </p>
<ul>
<li><a href="http://www.iro.umontreal.ca/~feeley/papers/DubeFeeleyACTAINFORMATICA00.pdf">Efficiently building a parse tree from a regular expression</a></li>
</ul>
</blockquote>
<p><strong>Algorithm 3.23</strong> : The <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">McNaughton-Yamada-Thompson algorithm</a> to convert a regular expression to an NFA.</p>
<p><strong>INPUT</strong>: A regular expression <code>r</code> over alphabet $\Sigma$.</p>
<p><strong>OUTPUT</strong>: An NFA <code>N</code> accepting <code>L(r )</code>.</p>
<p>METHOD: Begin by parsing <code>r</code> into its constituent subexpressions. The rules for constructing an NFA consist of <strong>basis rules</strong> for handling subexpressions with no operators, and <strong>inductive rules</strong> for constructing larger NFA's from the NFA's for the immediate subexpressions of a given expression.</p>
<p><strong>BASIS</strong>: For expression $\epsilon$ construct the NFA</p>
<p><img alt="" src="../Figure-epsilon-NFA.jpg" /></p>
<p>Here, <code>i</code> is a new state, the <strong>start state</strong> of this NFA, and <code>f</code> is another new state, the <strong>accepting state</strong> for the NFA.</p>
<p>For any subexpression a in $\Sigma$, construct the NFA</p>
<p><img alt="" src="../Figure-a-NFA.jpg" /></p>
<p>where again <code>i</code> and <code>f</code> are new states, the start and accepting states, respectively. Note that in both of the basis constructions, we construct a distinct NFA, with new states, for every occurrence of $\epsilon$ or some <code>a</code> as a subexpression of <code>r</code>.</p>
<p><strong>INDUCTION</strong>: Suppose <code>N (s)</code> and <code>N (t)</code> are NFA's for regular expressions <code>s</code> and <code>t</code>, respectively.</p>
<p>a) Suppose <code>r = s|t</code>. Then <code>N (r )</code>, the NFA for <code>r</code> , is constructed as in Fig. 3.40. Here, <code>i</code> and <code>f</code> are new states, the start and accepting states of <code>N (r )</code>, respectively. There are $\epsilon$-transitions from <code>i</code> to the start states of <code>N (s)</code> and <code>N (t)</code>, and each of their accepting states have $\epsilon$-transitions to the accepting state <code>f</code> . Note that the accepting states of <code>N (s)</code> and <code>N (t)</code> are not accepting in <code>N (r)</code>. Since any path from <code>i</code> to <code>f</code> must pass through either <code>N (s)</code> or <code>N (t)</code> exclusively, and since the label of that path is not changed by the $\epsilon$'s leaving <code>i</code> or entering <code>f</code> , we conclude that <code>N (r )</code> accepts $L(s) \cup L(t)$, which is the same as <code>L(r )</code>. That is, Fig. 3.40 is a correct construction for the union operator.</p>
<p><img alt="" src="../Figure3.40NFA-for-the-union-of-two-regular-expressions.jpg" /></p>
<p>b) Suppose <code>r = st</code>. Then construct <code>N (r )</code> as in Fig. 3.41. The <strong>start state</strong> of <code>N (s)</code> becomes the <strong>start state</strong> of <code>N (r )</code>, and the <strong>accepting state</strong> of <code>N (t)</code> is the only accepting state of <code>N (r )</code>. The <strong>accepting state</strong> of <code>N(s)</code> and the <strong>start state</strong> of <code>N (t)</code> are merged into a single state, with all the transitions in or out of either state. A path from <code>i</code> to <code>f</code> in Fig. 3.41 must go first through <code>N (s)</code>, and therefore its label will begin with some string in <code>L(s)</code>. The path then continues through <code>N (t)</code>, so the path's label finishes with a
string in <code>L(t)</code>. As we shall so on argue, <strong>accepting states</strong> never have edges out and start states never have edges in, so it is not possible for a path to re-enter <code>N (s)</code> after leaving it. Thus, <code>N (r )</code> accepts exactly <code>L(s)L(t)</code>, and is a correct NFA for <code>r = st</code>.</p>
<p><img alt="" src="../Figure3.41NFA-for-the-concatenation-of-two-regular-expressions.jpg" /></p>
<p>c) Suppose $r = s^<em>$. Then for <code>r</code> we construct the NFA <code>N (r )</code> shown in Fig. 3.42. Here, <code>i</code> and <code>f</code> are new states, the start state and lone accepting state of <code>N (r )</code>. To get from <code>i</code> to <code>f</code> , we can either follow the introduced path labeled $\epsilon$, which takes care of the one string in $L(s)^0$ , or we can go to the start state of <code>N(s)</code>, through that NFA, then from its accepting state back to its start state zero or more times. These options allow <code>N (r )</code> to accept all the strings in $L(s)^1$, $L(s)^2$, and so on, so the entire set of strings accepted by <code>N (r )</code> is $L(s^</em>)$.</p>
<p><img alt="" src="../Figure3.42NFA-for-the-closure-of-a-regular-expression.jpg" /></p>
<p>d) Finally, suppose <code>r = (s)</code>. Then <code>L(r ) = L(s)</code>, and we can use the NFA <code>N (s)</code> as <code>N (r )</code>.</p>
<blockquote>
<p>NOTE: Implementing a <a href="https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines">regular expression engine</a> is far more complex than the algorithm described here.</p>
</blockquote>
<p>The method description in Algorithm 3.23 contains hints as to why the <strong>inductive construction</strong> works as it should. We shall not give a formal correctness proof, but we shall list several properties of the constructed NFA's, in addition to the all-important fact that <code>N (r )</code> accepts language <code>L(r )</code>. These properties are interesting in their own right, and helpful in making a formal proof.</p>
<ol>
<li><code>N (r )</code> has at most twice as many states as there are operators and operands in <code>r</code> . This bound follows from the fact that each step of the algorithm creates at most two new states.</li>
<li><code>N (r )</code> has one <strong>start state</strong> and one <strong>accepting state</strong>. The accepting state has no outgoing transitions, and the start state has no incoming transitions.</li>
<li>Each state of <code>N (r )</code> other than the accepting state has either one outgoing transition on a symbol in $\Sigma$ or two outgoing transitions, both on $\epsilon$.</li>
</ol>
<p><strong>Example 3.24</strong> : Let us use Algorithm 3.23 to construct an NFA for $r = (a | b) ^*abb$. Figure 3.43 shows a <strong>parse tree</strong> for <code>r</code> that is analogous to the <strong>parse trees</strong> constructed for arithmetic expressions in Section 2.2.3. For subexpression $r_1$ , the first <code>a</code>, we construct the NFA:</p>
<p><img alt="" src="../Figure3.43Parse-tree-for.jpg" /></p>
<p><img alt="" src="../Figure-a-NFA-example3.24.jpg" /></p>
<p>State numbers have been chosen for consistency with what follows. For $r_2$ we construct:</p>
<p><img alt="" src="../Figure-b-NFA-example3.24.jpg" /></p>
<p>We can now combine $N (r_1)$ and $N (r_2)$, using the construction of Fig. 3.40 to obtain the NFA for $r_3
=r_1|r_2$; this NFA is shown in Fig. 3.44.</p>
<p><img alt="" src="../Figure3.44NFA-for-r3.jpg" /></p>
<p>The NFA for $r_4= (r_3)$ is the same as that for $r_3$. The NFA for $r_5= (r_3)$ is then as shown in Fig. 3.45. We have used the construction in Fig. 3.42 to build this NFA from the NFA in Fig. 3.44.</p>
<p><img alt="" src="../Figure-3.45-NFA-for-r5.jpg" /></p>
<p>Now, consider subexpression $r_6$, which is another <code>a</code>. We use the basis construction for <code>a</code> again, but we must use new states. It is not permissible to reuse the NFA we constructed for $r_1$, even though $r_1$ and $r_6$ are the same expression. The NFA for $r_6$ is:</p>
<p><img alt="" src="../Figure-a-NFA-example3.24-state7.jpg" /></p>
<p>To obtain the NFA for $r_7= r_5r_6$, we apply the construction of Fig. 3.41. We merge states 7 and $7^{'}$, yielding the NFA of Fig. 3.46. Continuing in this fashion with new NFA's for the two subexpressions <code>b</code> called $r_8$
and $r_{10}$, we eventually construct the NFA for  tha$r = (a | b) ^*abb$ that we first met in Fig. 3.34. </p>
<p><img alt="" src="../Figure3.46-NFA-for-r7.jpg" /></p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/dengking/compiler-principle" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
