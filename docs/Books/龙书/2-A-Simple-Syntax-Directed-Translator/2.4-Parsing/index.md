# 2.4 Parsing

Parsing is the process of determining how a string of **terminals** can be generated by a **grammar**. In discussing this problem, it is helpful to think of a **parse tree** being constructed, even though a compiler may not construct one, in practice. However, a parser must be capable of constructing the tree in principle, or else the translation cannot be guaranteed correct.

> NOTE: 
>
> The concept of parsing is introduced in chapter 2.2.2 Derivations

This section introduces a parsing method called "[recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser)," which can be used both to parse and to implement **syntax-directed translators**. A complete Java program, implementing the translation scheme of Fig. 2.15, appears in the next section. A viable alternative is to use a software tool to generate a translator directly from a translation scheme. Section 4.9 describes such a tool  Yacc; it can implement the translation scheme of Fig. 2.15 without modification.

For any context-free grammar there is a parser that takes at most $O (n^3)$ time to parse a string of n terminals. But cubic(立方的) time is generally too expensive. Fortunately, for real programming languages, we can generally design a grammar that can be parsed quickly. Linear-time algorithms suffice to parse essentially all languages that arise in practice. Programming-language parsers almost always make a single left-to-right scan over the input, looking ahead one terminal at a time, and constructing pieces of the parse tree as they go.

Most parsing methods fall into one of two classes, called the [top-down](https://en.wikipedia.org/wiki/Top-down_parsing) and [bottom-up](https://en.wikipedia.org/wiki/Bottom-up_parsing) methods. These terms refer to the order in which **nodes** in the **parse tree** are constructed. In **top-down parsers**, construction starts at the root and proceeds towards the leaves, while in **bottom-up parsers**, construction starts at the leaves and proceeds towards the root. The popularity of **top-down parsers** is due to the fact that efficient parsers can be constructed more easily by hand using **top-down methods**. Bottom-up parsing, however, can handle a larger class of grammars and translation schemes, so software tools for generating parsers directly from grammars often use **bottom-up methods**.

> NOTE:  
>
> 参见 wikipedia [Parsing algorithms](https://en.wikipedia.org/wiki/Parsing)

## 2.4.1 Top-Down Parsing

> NOTE:
>
> 一、tutorialspoint [Compiler Design - Top-Down Parser](https://www.tutorialspoint.com/compiler_design/compiler_design_top_down_parser.htm)
>
> 
>
> ![Top Down Parsing](https://www.tutorialspoint.com/compiler_design/images/top_down_parsing.jpg)

We introduce **top-down parsing** by considering a grammar that is well-suited for this class of methods. Later in this section, we consider the construction of **top-down parsers** in general. The grammar in Fig. 2.16 generates a subset of the statements of C or Java. We use the boldface terminals **if** and **for** for the keywords "`if`" and "`for`", respectively, to emphasize that these character sequences are treated as units, i.e., as single terminal symbols. Further, the terminal `expr` represents expressions; a more complete grammar would use a nonterminal `expr` and have productions for nonterminal `expr`. Similarly, `other` is a terminal representing other statement constructs.

![](./Figure-2.16-A-grammar-for-some-statements-in-C-and-Java.jpg)

The **top-down** construction of a **parse tree** like the one in Fig. 2.17, is done by starting with the root, labeled with the starting nonterminal `stmt`, and repeatedly performing the following two steps.

1、At node `N` , labeled with nonterminal `A`, select one of the productions for `A` and construct children at `N` for the symbols in the production body.

2、Find the next node at which a subtree is to be constructed, typically the **leftmost** unexpanded **nonterminal** of the tree.

> NOTE:
>
> 一、
>
> 两个pointer:
>
> 1、current node
>
> 2、***lookahead symbol***
>
> 
>
> 两种symbol/node:
>
> 1、terminal symbol
>
> 2、nonterminal symbol(base case)
>
> 需要考虑上述两种pointer在上述两种symbol 匹配的时候如何移动。
>
> 
>
> Initialization:
>
> top-down parser 是从 **starting nonterminal symbol** 开始的，初始化的时候parse tree的root node就是 **starting nonterminal symbol**，***lookahead symbol*** 指针指向的是input string的第一个terminal，这在下面会介绍("Initially, the **lookahead symbol** is the first, i.e., leftmost, terminal of the input string")。
>
> 对每个nonterminal symbol需要从它的众多production中选择一个，那如何选取呢？由***lookahead symbol***决定。
>
> 

![](./Figure-2.17-A-parse-tree-according-to-the-grammar-in-Fig2.16.jpg)



### Initialization

For some grammars, the above steps can be implemented during a single left-to-right scan of the input string. The **current terminal** being scanned in the input is frequently referred to as the ***lookahead symbol***. Initially, the **lookahead symbol** is the first, i.e., leftmost, terminal of the input string. Figure 2.18 illustrates the construction of the **parse tree** in Fig. 2.17 for the input string

```pseudocode
for ( ; expr ; expr ) other
```

Initially, the terminal `for` is the **lookahead symbol**, and the known part of the **parse tree** consists of the **root**, labeled with the **starting nonterminal `stmt`** in Fig. 2.18(a). The objective is to construct the remainder of the **parse tree** in such a way that the string generated by the **parse tree** matches the input string.

### Match nonterminal symbol

For a match to occur, the nonterminal `stmt` in Fig. 2.18(a) must derive(派生、expand) a string that starts with the **lookahead symbol** `for`. In the grammar of Fig. 2.16, there is just one production for `stmt` that can derive such a string, so we select it, and construct the children of the root labeled with the symbols in the **production body**. This **expansion** of the **parse tree** is shown in Fig. 2.18(b).

> NOTE:
>
> 一、"For a match to occur, the nonterminal `stmt` in Fig. 2.18(a) must derive(派生、expand) a string that starts with the **lookahead symbol** `for`"
>
> 上面这段话是关键所在，在众多production中选择哪个？这是可以通过**lookahead symbol**来帮助抉择
>
> 上面这段话描述的是expand过程。

Each of the three snapshots in Fig. 2.18 has arrows marking the **lookahead symbol** in the input and the node in the **parse tree** that is being considered. Once children are constructed at a node, we next consider the **leftmost child**. In Fig. 2.18(b), children have just been constructed at the root, and the **leftmost child** labeled with **for** is being considered.

> NOTE:
>
> 一、上面描述的是move current node pointer



![](./Figure-2.18-Top-down-parsing-while-scanning-the-input-from-left-to-right.jpg)

### Match terminal symbol

When the node being considered in the **parse tree** is for a **terminal**, and the **terminal** matches the **lookahead symbol**, then we advance in both the **parse tree** and the **input**. The next terminal in the input becomes the new **lookahead symbol**, and the next child in the **parse tree** is considered. In Fig. 2.18(c), the arrow in the **parse tree** has advanced to the **next child** of the root, and the arrow in the input has advanced to the **next terminal**, which is `(`. A further advance will take the arrow in the **parse tree** to the child labeled with nonterminal `optexpr` and take the arrow in the input to the terminal `;`.

### $\epsilon$ -production

At the nonterminal node labeled `optexpr`, we repeat the process of selecting a production for a nonterminal. Productions with $\epsilon$ as the body (" $\epsilon$ -productions") require special treatment. For the moment, we use them as a default when no other production can be used; we return to them in Section 2.4.3. With nonterminal `optexpr` and lookahead `;`, the $\epsilon$ -productions is used, since `;` does not match the only other production for `optexpr`, which has terminal `expr` as its body.

### 承上启下

In general, the selection of a production for a nonterminal may involve [trial-and-error](https://en.wikipedia.org/wiki/Trial_and_error); that is, we may have to try a production and [backtrack](https://en.wikipedia.org/wiki/Backtracking) to try another production if the first is found to be unsuitable. A production is unsuitable if, after using the production, we cannot complete the tree to match the input string. Backtracking is not needed, however, in an important special case called **predictive parsing**, which we discuss next.



## 2.4.2 Predictive Parsing

*Recursive-descent parsing* is a top-down method of syntax analysis in which a set of recursive procedures is used to process the input. **One procedure is associated with each nonterminal of a grammar**. Here, we consider a simple form of **recursive-descent parsing**, called *predictive parsing*, in which the **lookahead symbol** unambiguously determines the flow of control through the procedure body for each **nonterminal**. The sequence of procedure calls during the analysis of an input string **implicitly** defines a **parse tree** for the input, and can be used to build an **explicit parse tree**, if desired.

> NOTE:
>
> 一、"**One procedure is associated with each nonterminal of a grammar**"
>
> 现实世界中的recursive- descend parser是否也是如此呢？

The **predictive parser** in Fig. 2.19 consists of procedures for the nonterminals `stmt` and `optexpr` of the grammar in Fig. 2.16 and an additional procedure `match`, used to simplify the code for `stmt` and `optexpr`. Procedure `match(t)` compares its argument `t` with the **lookahead symbol** and advances to the next input terminal if they match. Thus `match` changes the value of variable `lookahead`, a **global variable** that holds the currently scanned input terminal.

```pseudocode
void stmt () {
    switch ( lookahead ) {
    case expr:
    	match (expr); match (';'); break;
    case 'if':
    	match ('if'); match ('('); match (expr); match (')'); stmt ();
    	break;
    case 'for':
    	match ('for'); match ('(');
    	optexpr (); match (';'); optexpr (); match (';'); optexpr ();
    	match (')'); stmt (); break;
    case other;
    	match (other); break;
    default:
    	report ("syntax error");
}

void optexpr () {
    if ( lookahead == expr ) match (expr);
}

void match (terminal t) {
    if ( lookahead == t ) lookahead = nextTerminal;
    else report ("syntax error");
}
```

Figure 2.19: Pseudo code for a predictive parser

> NOTE: 
>
> 一、A predictive parsing approach is one that hardcodes the grammar into the program



Parsing begins with a call of the procedure for the **starting nonterminal** `stmt`. With the same input as in Fig. 2.18, `lookahead` is initially the first terminal `for`. Procedure `stmt` executes code corresponding to the production
$$
stmt \to for ( optexpr ; optexpr ; optexpr ) stmt
$$
In the code for the **production body** -- that is, the for case of procedure `stmt`--each terminal is matched with the **lookahead symbol**, and each nonterminal leads to a call of its procedure, in the following sequence of calls:

```pseudocode
match (for); match ('(');
optexpr (); match (';'); optexpr (); match (';'); optexpr ();
match (')'); stmt ();
```

**Predictive parsing** relies on information about the first symbols that can be generated by a **production body**. More precisely, let $\alpha$ be a string of grammar symbols (terminals and/or nonterminals). We define $FIRST (\alpha)$ to be the set of terminals that appear as the first symbols of one or more strings of terminals generated from $\alpha$. If $\alpha$ is $\epsilon$ or can generate  $\epsilon$ , then  $\epsilon$  is also in $FIRST (\alpha)$.

> NOTE: 
>
> Only when $FIRST (\alpha)$ is known, can flow of control determine.

The details of how one computes $FIRST (\alpha)$ are in Section 4.4.2. Here, we shall just use ad hoc(特别的) reasoning to deduce the symbols in $FIRST (\alpha)$; typically, $\alpha$  will either begin with a terminal, which is therefore the only symbol in $FIRST (\alpha)$, or $\alpha$ will begin with a nonterminal whose production bodies begin with terminals, in which case these terminals are the only members of $FIRST (\alpha)$.

For example, with respect to the grammar of Fig. 2.16, the following are correct calculations of $FIRST$.

```
FIRST (stmt) = {expr; if; for; other}
FIRST(expr ;) = {expr}
```

> NOTE: `FIRST (stmt) ` corresponds to the case of `void stmt ()`.

The FIRST sets must be considered if there are two pro ductions $A \to \alpha$ and $A \to \beta$ . Ignoring $\epsilon$- productions for the moment, predictive parsing requires $FIRST (\alpha)$ and $FIRST(\beta )$ to be disjoint. The **lookahead symbol** can then be used to decide which production to use; if the lookahead symbol is in $FIRST (\alpha)$, then $\alpha$ is used. Otherwise, if the lookahead symbol is in $FIRST (\beta)$, then $\beta$ is used.



## 2.4.3 When to Use $\epsilon$-Productions

Our **predictive parser** uses an $\epsilon$-production as a default when no other production can be used. With the input of Fig. 2.18, after the terminals `for` and `(` are matched, the **lookahead symbol** is `;`. At this point procedure `optexpr` is called, and the code

```c++
if ( lookahead == expr ) match(expr);
```

in its body is executed. Nonterminal `optexpr` has two productions, with bodies `expr` and $\epsilon$. The **lookahead symbol** "`;`" does not match the terminal `expr`, so the production with body `expr` cannot apply. In fact, the procedure returns without changing the **lookahead symbol** or doing anything else. In fact, the procedure returns without changing the **lookahead symbol** or doing anything else. Doing nothing corresponds to applying an $\epsilon$-production.

More generally, consider a variant of the productions in Fig. 2.16 where `optexpr` generates an expression nonterminal instead of the terminal `expr`:
$$
optexpr \to expr | \epsilon
$$
Thus, `optexpr` either generates an expression using nonterminal `expr` or it generates $\epsilon$ . While parsing `optexpr`, if the **lookahead symbol** is not in `FIRST(expr)`, then the $\epsilon$-production is used.

For more on when to use $\epsilon$-productions, see the discussion of LL(1) grammars in Section 4.4.3.



## 2.4.4 Designing a Predictive Parser 

We can generalize the technique introduced informally in Section 2.4.2, to apply to any grammar that has disjoint FIRST sets for the production bodies belonging to any nonterminal. We shall also see that when we have a **translation scheme**--that is, a grammar with embedded actions | it is possible to execute those actions as part of the procedures designed for the parser.



## 2.4.5 Left Recursion 

It is possible for a **recursive-descent parser** to loop forever. A problem arises with "**left-recursive**" productions like
$$
expr \to expr + term
$$
where the leftmost symbol of the body is the same as the **nonterminal** at the head of the production. Suppose the procedure for `expr` decides to apply this production. The body begins with `expr` so the procedure for `expr` is called recursively. Since the **lookahead symbol** changes only when a **terminal** in the body is matched, no change to the input took place between recursive calls of `expr`. As a result, the second call to `expr` does exactly what the first call did, which means a third call to `expr`, and so on, forever.

A **left-recursive production** can be eliminated by rewriting the offending production. 

> NOTE:
>
> 一、转换方法: 将 **left-recursive production** 转换为 **right recursive production**，关于此，参见:
>
> 1、gatevidyalay [Left Recursion | Left Recursion Elimination](https://www.gatevidyalay.com/left-recursion-left-recursion-elimination/) 
>
> 2、csd.uwo.ca [Elimination of left recursion](https://www.csd.uwo.ca/~mmorenom/CS447/Lectures/Syntax.html/node8.html) 
>
> 3、educative [What is left recursion and how do you eliminate left recursion?](https://www.educative.io/answers/what-is-left-recursion-and-how-do-you-eliminate-left-recursion)

Consider a nonterminal `A` with two productions
$$
A \to A \alpha | \beta
$$
where  $\alpha$ and $\beta$ are sequences of **terminals** and **nonterminals** that do not start with A. For example, in
$$
expr \to expr + term | term
$$
**nonterminal**  $A = expr$, string $\alpha = + term$, and string $\beta = term$.




The same effect can be achieved, as in Fig. 2.20(b), by rewriting the productions for `A` in the following manner, using a new nonterminal `R`:
$$
A \to \beta R \\ R \to \alpha R | \epsilon
$$

The nonterminal `A` and its production are said to be **left recursive**, because the production $A \to A \alpha$ has `A` itself as the leftmost symbol on the right side(In a general **left-recursive** grammar, instead of a production $A \to A$, the nonterminal `A` may derive `A` through intermediate productions). Repeated application of this production builds up a sequence of $\alpha$ 's to the right of `A`, as in Fig. 2.20(a). When `A` is finally replaced by $\beta$, we have a $\beta$ followed by a sequence of zero or more $\alpha$'s.

The same effect can be achieved, as in Fig. 2.20(b), by rewriting the productions for `A` in the following manner, using a new nonterminal $R$:
$$
A \to \beta R \\ R \to \alpha R | \epsilon
$$
Nonterminal `R` and its production $R \to \alpha R$ are right recursive because this production for R has R itself as the last symbol on the right side. **Right-recursive productions** lead to trees that grow down towards the right, as in Fig. 2.20(b). Trees growing down to the right make it harder to translate expressions containing **left-associative operators**, such as minus. In Section 2.5.2, however, we shall see that the proper translation of expressions into postx notation canstill be attained by a careful design of the translation scheme.

