[TOC]



# [Comparison of parser generators](https://en.wikipedia.org/wiki/Comparison_of_parser_generators)

This is a list of notable [lexer generators](https://en.wikipedia.org/wiki/Lexer_generator) and [parser generators](https://en.wikipedia.org/wiki/Parser_generator) for various language classes.

## Regular languages

[Regular languages](https://en.wikipedia.org/wiki/Regular_language) are a category of languages (sometimes termed [Chomsky Type 3](https://en.wikipedia.org/wiki/Chomsky_hierarchy)) which can be matched by a **state machine** (more specifically, by a [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) or a [nondeterministic finite automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton)) constructed from a [regular expression](https://en.wikipedia.org/wiki/Regular_expression). In particular, a regular language can match constructs like "A follows B", "Either A or B", "A, followed by zero or more instances of B", but cannot match constructs which require consistency between non-adjacent elements, such as "some instances of A followed by the same number of instances of B", and also cannot express the concept of recursive "nesting" ("every A is eventually followed by a matching B"). A classic example of a problem which a regular grammar cannot handle is the question of whether a given string contains correctly-nested parentheses. (This is typically handled by a Chomsky Type 2 grammar, also termed a [context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar).)

*See also:* [List of lexer generators](https://en.wikipedia.org/wiki/List_of_lexer_generators)

|                             Name                             |                       Lexer algorithm                        | [Output languages](https://en.wikipedia.org/wiki/Programming_language) | Grammar, code |             Development platform             |  [License](https://en.wikipedia.org/wiki/Software_license)   |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------: | :------------------------------------------: | :----------------------------------------------------------: |
| [Flex](https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)) | [DFA](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) table driven | [C](https://en.wikipedia.org/wiki/C_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B) |     Mixed     |                     All                      |   Free, [BSD](https://en.wikipedia.org/wiki/BSD_licenses)    |
|     [lex](https://en.wikipedia.org/wiki/Lex_(software))      | [DFA](https://en.wikipedia.org/wiki/Deterministic_finite_automaton) | [C](https://en.wikipedia.org/wiki/C_(programming_language))  |     Mixed     | [POSIX](https://en.wikipedia.org/wiki/POSIX) | Partial, [proprietary](https://en.wikipedia.org/wiki/Proprietary_software), [CDDL](https://en.wikipedia.org/wiki/Common_Development_and_Distribution_License) |



## Deterministic context-free languages

[Context-free languages](https://en.wikipedia.org/wiki/Context-free_language) are a category of languages (sometimes termed [Chomsky Type 2](https://en.wikipedia.org/wiki/Chomsky_hierarchy)) which can be matched by a sequence of replacement rules, each of which essentially maps each **non-terminal** element to a sequence of **terminal** elements and/or other **nonterminal** elements. Grammars of this type can match anything that can be matched by a [regular grammar](https://en.wikipedia.org/wiki/Regular_grammar), and furthermore, can handle the concept of recursive "nesting" ("every A is eventually followed by a matching B"), such as the question of whether a given string contains correctly-nested parentheses. The rules of **Context-free grammars** are purely **local**, however, and therefore cannot handle questions that require **non-local** analysis such as "Does a declaration exist for every variable that is used in a function?". To do so technically would require a more sophisticated grammar, like a Chomsky Type 1 grammar, also termed a [context-sensitive grammar](https://en.wikipedia.org/wiki/Context-sensitive_grammar). However, **parser generators** for **context-free grammars** often support the ability for user-written code to introduce limited amounts of **context-sensitivity**. (For example, upon encountering a variable declaration, user-written code could save the name and type of the variable into an external data structure, so that these could be checked against later variable references detected by the parser.)

The [deterministic context-free languages](https://en.wikipedia.org/wiki/Deterministic_context-free_language) are a proper subset of the context-free languages which can be efficiently parsed by [deterministic pushdown automata](https://en.wikipedia.org/wiki/Deterministic_pushdown_automata).

|                             Name                             |  [Parsing](https://en.wikipedia.org/wiki/Parsing) algorithm  |                    Input grammar notation                    | [Output languages](https://en.wikipedia.org/wiki/Programming_language) | Grammar, code | [Lexer](https://en.wikipedia.org/wiki/Lexical_analyzer) |                     Development platform                     | [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) |  [License](https://en.wikipedia.org/wiki/Software_license)   |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------: | :-----------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| [Spirit](https://en.wikipedia.org/wiki/Spirit_Parser_Framework) | [Recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser) |                              ?                               |         [C++](https://en.wikipedia.org/wiki/C%2B%2B)         |     Mixed     |                        internal                         |                             All                              |                              No                              | Free, [Boost](https://en.wikipedia.org/wiki/Boost_Software_License) |
|         [Parse](https://github.com/MathiasVP/Parse/)         |  [LR](https://en.wikipedia.org/wiki/Canonical_LR_parser)(1)  |  BNF in [C++](https://en.wikipedia.org/wiki/C%2B%2B) types   |                              ?                               |       ?       |                          none                           |                   C++11 standard compiler                    |                              No                              |    Free, [MIT](https://en.wikipedia.org/wiki/MIT_License)    |
|                             APG                              | [Recursive descent](https://en.wikipedia.org/wiki/Recursive_descent), [backtracking](https://en.wikipedia.org/wiki/Backtracking) |          [ABNF](https://en.wikipedia.org/wiki/ABNF)          | [C](https://en.wikipedia.org/wiki/C_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) |   Separate    |                          none                           |                             All                              |                              No                              | Free, [GNU GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License) |
|        [ANTLR](https://en.wikipedia.org/wiki/ANTLR)4         | [ALL](https://en.wikipedia.org/wiki/LL_parser)(*)[[2\]](https://en.wikipedia.org/wiki/Comparison_of_parser_generators#cite_note-2) | [EBNF](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form) | [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [Swift](https://en.wikipedia.org/wiki/Swift_(programming_language)), [Go](https://en.wikipedia.org/wiki/Go_(programming_language)), [PHP](https://en.wikipedia.org/wiki/PHP) |     Mixed     |                        generated                        | [Java virtual machine](https://en.wikipedia.org/wiki/Java_virtual_machine) |                             Yes                              |   Free, [BSD](https://en.wikipedia.org/wiki/BSD_licenses)    |
|        [ANTLR](https://en.wikipedia.org/wiki/ANTLR)3         |       [LL](https://en.wikipedia.org/wiki/LL_parser)(*)       | [EBNF](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form) | [ActionScript](https://en.wikipedia.org/wiki/ActionScript), [Ada95](https://en.wikipedia.org/wiki/Ada_(programming_language)), [C](https://en.wikipedia.org/wiki/C_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Objective-C](https://en.wikipedia.org/wiki/Objective-C), [Perl](https://en.wikipedia.org/wiki/Perl), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)) |     Mixed     |                        generated                        | [Java virtual machine](https://en.wikipedia.org/wiki/Java_virtual_machine) |                             Yes                              |   Free, [BSD](https://en.wikipedia.org/wiki/BSD_licenses)    |
|       [Bison](https://en.wikipedia.org/wiki/GNU_Bison)       | [LALR](https://en.wikipedia.org/wiki/LALR_parser)(1), [LR](https://en.wikipedia.org/wiki/Canonical_LR_parser)(1), [IELR](https://en.wikipedia.org/w/index.php?title=IELR_parser&action=edit&redlink=1)(1), [GLR](https://en.wikipedia.org/wiki/GLR_parser) |          [Yacc](https://en.wikipedia.org/wiki/Yacc)          | [C](https://en.wikipedia.org/wiki/C_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) |     Mixed     |                        external                         |                             All                              |                              No                              | Free, [GNU GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License) with exception |
| [Yacc](https://en.wikipedia.org/wiki/Yacc) [AT&T](https://en.wikipedia.org/wiki/AT%26T_Corporation)/[Sun](https://en.wikipedia.org/wiki/Sun_Microsystems) |     [LALR](https://en.wikipedia.org/wiki/LALR_parser)(1)     |          [Yacc](https://en.wikipedia.org/wiki/Yacc)          | [C](https://en.wikipedia.org/wiki/C_(programming_language))  |     Mixed     |                        external                         |         [POSIX](https://en.wikipedia.org/wiki/POSIX)         |                              No                              | Free, [CPL](https://en.wikipedia.org/wiki/Common_Public_License) & [CDDL](https://en.wikipedia.org/wiki/Common_Development_and_Distribution_License) |
| [BtYacc](https://en.wikipedia.org/w/index.php?title=BtYacc&action=edit&redlink=1) | [Backtracking](https://en.wikipedia.org/wiki/Backtracking) [Bottom-up](https://en.wikipedia.org/wiki/Bottom-up_parsing) |                              ?                               |         [C++](https://en.wikipedia.org/wiki/C%2B%2B)         |     Mixed     |                        external                         |                             All                              |                              No                              | Free, [public domain](https://en.wikipedia.org/wiki/Public_domain) |

## Parsing expression grammars, deterministic boolean grammars

This table compares parser generators with [parsing expression grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar), deterministic [boolean grammars](https://en.wikipedia.org/wiki/Boolean_grammar).

|               Name               | [Parsing](https://en.wikipedia.org/wiki/Parsing) algorithm | [Output languages](https://en.wikipedia.org/wiki/Programming_language) | Grammar, code | Development platform |  [License](https://en.wikipedia.org/wiki/Software_license)   |
| :------------------------------: | :--------------------------------------------------------: | :----------------------------------------------------------: | :-----------: | :------------------: | :----------------------------------------------------------: |
|             Arpeggio             |              PEG parser interpreter, Packrat               | [Python](https://en.wikipedia.org/wiki/Python_(programming_language)) (no generation, interpreted) |     Mixed     |         All          |    Free, [MIT](https://en.wikipedia.org/wiki/MIT_License)    |
| [pyPEG](https://fdik.org/pyPEG/) |              PEG parser interpreter, Packrat               | [Python](https://en.wikipedia.org/wiki/Python_(programming_language)) |     Mixed     |         All          | Free, [GNU GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License) |

