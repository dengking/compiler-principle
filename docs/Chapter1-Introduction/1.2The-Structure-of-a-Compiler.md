[TOC]



# 1.2 The Structure of a Compiler

Up to this point we have treated a compiler as a single b ox that maps a source program into a semantically equivalent target program. If we op en up this box a little, we see that there are two parts to this mapping: 

- analysis
- synthesis

The *analysis* part breaks up the source program into constituent pieces and imposes a grammatical structure on them. It then uses this structure to create an **intermediate representation** of the source program. If the analysis part detects that the source program is either syntactically ill formed or semantically unsound, then it must provide informative messages, so the user can take corrective action. The analysis part also collects information ab out the source program and stores it in a data structure called a *symbol table*, which is passed along with the **intermediate representation** to the **synthesis part**.

The *synthesis* part constructs the desired target program from the **intermediate representation** and the information in the symbol table. 

The **analysis part** is often called the *front end* of the compiler; the **synthesis part** is the **back end**.

If we examine the compilation process in more detail, we see that it operates as a sequence of *phases*, each of which transforms one representation of the source program to another. A typical decomposition of a compiler into phases is shown in Fig. 1.6. In practice, several phases may be grouped together, and the intermediate representations between the grouped phases need not be constructed explicitly. 

The **symbol table**, which stores information about the entire source program, is used by all phases of the compiler.

![](./Figure1.6Phases-of-a-compiler.jpg)

Some compilers have a **machine-independent optimization** phase between the **front end** and the **back end**. The purpose of this optimization phase is to perform transformations on the **intermediate representation**, so that the back end can produce a better target program than it would have otherwise produced from an unoptimized intermediate representation. Since optimization is optional, one or the other of the two optimization phases shown in Fig. 1.6 may be missing.

> NOTE: 图1.6给出了一个compiler的架构，这个架构是清晰的，作为一名软件工程师，我们可以尝试思考一下如何来实现一个编译器，如下是两种策略：
>
> - 分开实现各个部件然后将它们组装成一个完整的编译器，每个部件可以独立工作（耦合度低）
> - 所有功能集成起来形成一个monolithic compiler，不能独立地使用其中某个部件（耦合度高）
>
> 目前c系语言中最流行的两款编译器：[gcc](https://gcc.gnu.org/)和[clang](https://llvm.org/)。在clang的官方网站的文章[Clang vs Other Open Source Compilers](https://clang.llvm.org/comparison.html)中，给出了这两款编译器的对比（各自的长处与短处），下面是两种的差异之一：
>
> > Clang is designed as an API from its inception, allowing it to be reused by source analysis tools, refactoring, IDEs (etc) as well as for code generation. GCC is built as a monolithic static compiler, which makes it extremely difficult to use as an API and integrate into other tools. Further, its historic design and [current](https://gcc.gnu.org/ml/gcc/2007-11/msg00460.html) [policy](https://gcc.gnu.org/ml/gcc/2004-12/msg00888.html) makes it difficult to decouple the front-end from the rest of the compiler.
>
> 显然，clang所采取的是第一种策略，gcc所采取的是第二种策略，正如在这篇文章中作者提出的观点
>
> > **differences in goals lead to different strengths and weaknesses**
>
> 我觉得是非常正确的。在clang的官方文档中，将clang的这种设计策略称为：[Library Based Architecture](https://clang.llvm.org/features.html#libraryarch)。
>
> 这两款编译器的架构所采取的截然不同的两种策略是软件设计领域一个非常典型的问题。
>
> 抛开软件设计不谈，回归本书。本书所讲述的是编译器的设计原理，是纯理论上的，如图1.6所展示的编译器的构成，本书会分章节来介绍编译器各个部分的设计原理，从前端到后端。实践是有助于理论的理解的，所以我们必须要使用一些工具来验证这些理论。clang作为一个工业级别的完整的、成熟的编译器，它实现了图1.6所展示的编译器的各个部分，而且它的[Library Based Architecture](https://clang.llvm.org/features.html#libraryarch)，使得基本上编译器的每个部分都对应为它的一个库，这些库有着简介的API，并且文档详尽，所以我们可以使用clang来作为学习编译器各个部件的好工具。
>
> 除此之外，[python](https://docs.python.org/3/)也可以作为学习编译原理的非常好的工具：
>
> - Design of CPython’s Compiler[¶](https://devguide.python.org/compiler/#design-of-cpython-s-compiler)，其中给出cpython编译器的设计
> - Python Language Services[¶](https://docs.python.org/3/library/language.html#python-language-services)，这是python标准库提供的module，these modules support tokenizing, parsing, syntax analysis, bytecode disassembly, and various other facilities.
>
> 结合这些工具，我们能够详尽地观察编译器各个部件的工作原理。



